<section data-type="chapter">
<h1>Basic Print Layout Properties</h1>

<p>In this chapter:</p>

<ul>
	<li>margins</li>
	<li>padding</li>
	<li>Units: in or pt vs. px</li>
	<li>box sizes (later, @page)</li>
	<li>positioning</li>
	<li>floats
	<ul>
		<li>http://alistapart.com/article/goingtoprint/</li>
	</ul>
	</li>
	<li>pagebreaks</li>
	<li>images</li>
	<li>backgrounds (move to print vs. web?)
	<ul>
		<li>Remove colors and images. You can do this all at once with the shorthand background property.</li>
	</ul>
	</li>
	<li>colors (move to print vs. web?)
	<ul>
		<li>Many people don't have colored printers. Also, colored ink is expensive. Respect your users' wallets.</li>
	</ul>
	</li>
	<li>&nbsp;</li>
</ul>

<p>These are all properties you use for web layout, but they can have different uses when it comes to print.</p>

<section data-type="sect1">
<h1>Page Breaks</h1>

<p>When dealing with scrolling content, you don't have to worry too much about how your content is being chunked--it's all just one even, unbroken block. However, when it comes to paged media, every page is a discrete canvas; this means that when you run out of space for your content on one page, the content will break over to a new page. Fortunately you've got some control over how and where these page breaks occur.</p>

<p>The primary properties for setting pagebreaks are page-break-before and page-break-after. Both of these properties accept the same values:&nbsp;auto, always, avoid, left, right, initial, and inherit. Setting either property to auto will allow the content to break naturally, without any intervention from you. We'll discuss the other primary values in the following sections.</p>

<section data-type="sect2">
<h2>Universal Page Breaks (<code>always</code>, <code>avoid</code>)</h2>

<p>text</p>
</section>

<section data-type="sect2">
<h2>Relative Page Breaks (<code>right</code>, <code>left</code>)</h2>

<p>You can also force a section to start on a particular page--left or right. For example, many professional publishers prefer that all new chapters start on a right-hand page.</p>

<pre data-code-language="css" data-original-title="" data-type="programlisting" title="">
section.chapter {
  page-break-before: right;
}
</pre>

<p>This code says that for every section with a class of chapter, add a pagebreak before that section to ensure that it starts on a right-hand page. It's that simple. Other available values for this property are TKTK.</p>

<p>Of course, in this scenario you could run into trouble if you have two section.chapter HTML elements as siblings, and the first section.chapter ends on a right-hand page. Technically this meets our defined requirements: the next section.chapter is indeed starting on a right-hand page, so no new pagebreak is needed. However, this isn't the desired behavior--we actually want every section.chapter to start on a <em>new</em> right-hand page. We can fix this by combining a couple of page-break rules:</p>

<pre data-code-language="css" data-original-title="" data-type="programlisting" title="">
section.chapter {
  page-break-before: right;
  page-break-after: always;
}
</pre>

<p>Here's what will happen in our two-neighboring-section.chapter scenario: the first section.chapter still ends on a right-hand page. However, because we added a page-break-after requirement, the next section won't start immediately, but will be pushed two pages later--it's pushed to the next page because of page-break-after, and because of our page-break-before: right requirement, it's pushed one more page back so that it starts on a right-hand page. We thus have the last page of the first section.chapter on a right-hand page, then a blank left-hand page, then the first page of the next section.chapter on a fresh right-hand page.</p>

<div data-type="note">
<h1>Note</h1>

<p>Learn how to style blank pages later in TKTK.</p>
</div>
</section>

<section data-type="sect2">
<h2>At-Will Page Breaks</h2>

<p>Adding more targeted pagebreaks is a little trickier, and will most likely entail making some additions to your source markup.</p>

<p>If your source is extremely stable or highly-structured, you can add pagebreaks using the cascade, in the same way you'd add any CSS styles.</p>

<p>However, if your DOM is likely to change, your better bet is to add a custom class to your HTML in the places you want to add a pagebreak.</p>
</section>

<section data-type="sect2">
<h2>Restricting Page Breaks with <code>page-break-inside</code></h2>

<p>If you have elements that you don't want to break across pages, you can use the <code>page-break-inside</code> property to restrict how and where the element can reflow. The main usefulness of <code>page-break-inside</code> is to restrict an element from breaking across pages, and so it only accepts four values:&nbsp;<code>auto</code>, <code>avoid</code>, <code>initial</code>, and <code>inherit</code> (<code>avoid</code> being the primary value for this property).</p>

<p>For example, say you have a <code>div</code> element with a class of <code>note</code>, and containing a few lines of note text. You want all the text to stay together on the same page, so your CSS would look like this:<br />
&nbsp;</p>

<pre data-code-language="css" data-original-title="" data-type="programlisting" title="">
div.note {
&nbsp; page-break-inside: avoid;
}
</pre>

<p>This CSS, of course, will also apply to any other div elements that have a class of note.&nbsp;</p>

<aside data-type="sidebar">
<h5>Avoid vs. Never</h5>

<p><span style="line-height: 1.5em;">You may wonder why one of the allowed values is <code>always</code>, but there is no &quot;never&quot;--instead, there's just <code>avoid</code>. But it makes sense if you think about it. What if your HTML element content was longer than just one page, and yet you'd applied <code>page-break-inside: never</code>? Presumably, the rest of your document would break across infinite blank pages as it searched for a page on which the long element would fit. Instead, by limiting the value to <code>avoid</code>, the rendering engine will do its best not to break the element across pages, but if it runs into a situation like the above where a break is unavoidable, it'll go ahead and split your element, rather than create an infinite loop.</span></p>
</aside>

<p>text</p>
</section>

<p>Text</p>
</section>

<p>&nbsp;</p>
</section>
